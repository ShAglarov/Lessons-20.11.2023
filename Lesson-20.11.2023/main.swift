//
//  main.swift
//  Lesson-20.11.2023
//
//  Created by Shamil Aglarov on 20.11.2023.
//

import Foundation

//------------Еще разница между struct и class-----------------------
/*
 1_Ссылочный тип vs Значимый тип:
 *_ Классы являются ссылочными типами. Это означает, что когда вы присваиваете экземпляр
    класса переменной или константе, вы фактически присваиваете ссылку на этот объект.
 *_ Структуры являются значимыми типами. Когда вы присваиваете экземпляр структуры
    переменной или константе, создается копия этой структуры.
 2_Наследование:
 *_ Классы могут наследовать свойства и методы от других классов.
 *_ Структуры не поддерживают наследование.
 3_Деинициализаторы:
 *_ Классы могут иметь деинициализаторы, которые выполняют определенный код перед тем,
    как экземпляр удаляется из памяти.
 *_ Структуры не имеют деинициализаторов.
 4_Идентичность и равенство:
 *_ У классов есть понятие "идентичности".
    Вы можете проверить, указывают ли две переменные на один и тот же объект с помощью операторов "===" и "!==".
 *_ Структуры не имеют понятия идентичности. Они сравниваются только на равенство.
 5_Возможность изменения свойств:
 *_ Для классов, если свойство объявлено как var, то оно может быть изменено из любого экземпляра,
    даже если этот экземпляр объявлен как let.
 *_ Для структур, если экземпляр объявлен как let, то все его свойства становятся неизменяемыми,
    независимо от того, были ли свойства объявлены как var или let.
 6_ARC (Automatic Reference Counting):
 *_ Классы поддерживают автоматическое подсчета ссылок (ARC), которое управляет жизненным циклом экземпляра.
    Это может привести к утечкам памяти, если не управлять сильными циклическими ссылками (например, с использованием weak или unowned).
 *_ Структуры не участвуют в ARC, так как они копируются при передаче и не используют ссылочный подсчет.
 7_Синтаксис инициализации:
 *_ Структуры автоматически получают инициализатор "по членам", который позволяет инициализировать каждое свойство структуры.
 *_ Классам такой инициализатор предоставляется автоматически только в отсутствие пользовательских инициализаторов.
 8_Мутация Методов:
 *_ В структурах, методы, которые изменяют свойства структуры, должны быть помечены ключевым словом mutating.
   Это делает очевидным, что метод изменяет структуру.
 *_ В классах такой необходимости нет, так как любой метод может изменить свойства класса.
 9_Type Casting:
 *_ Классы поддерживают приведение типов (type casting) с использованием as?, as! и is.
 *_ Структуры не поддерживают приведение типов в иерархии наследования, так как у них нет наследования.
 8_Extensions:
 И классы, и структуры могут быть расширены с помощью extension, но если вы добавите
 новый инициализатор в расширении структуры, он не сможет изменять свойства,
 объявленные как let, если у них уже есть значения по умолчанию.
 9_Ключевое слово self:
 В Swift ключевое слово self используется для обозначения текущего экземпляра объекта, структуры или перечисления.
 Однако его использование и поведение слегка различаются в контексте классов и структур.
 *_ В классах: self обычно используется для различия свойств и методов класса от
    параметров функций или для ссылки на текущий экземпляр класса. 

 *_ В структурах: Как и в классах, self указывает на текущий экземпляр структуры.
    Однако при работе с методами, которые модифицируют структуру (отмечены как mutating),
    self представляет измененный экземпляр, который заменяет исходный экземпляр после завершения метода.
 */

//struct Point {
//    var x: Int
//    var y: Int
//}
//
////var point1 = Point(x: 6, y: 1)
////print("point1 =\nx = \(point1.x) \ny = \(point1.y)")
//
//class Point2 {
//    let x: Int
//    let y: Int
//    
//    init(x: Int, y: Int) {
//        self.x = x
//        self.y = y
//    }
//    
//    init() {
//        self.x = 0
//        self.y = 0
//    }
//    
//    init(x: Int) {
//        self.x = x
//        self.y = x + 10
//    }
//}
//
////var point2 = Point2()
//
//func updatePoint(_ point: Point) {
//    var tempPoint = point
//    tempPoint.x = 10
//    tempPoint.y = 5
//    
   // point1 = tempPoint
//}

//func updatePoint2(_ point: Point2) {
//    point.x = 10
//    point.y = 15
//}


//updatePoint2(point2)


//print("point2 =\nx = \(point2.x) \ny = \(point2.y)")


//let pointStruct = Point(x: 0, y: 0)
//let pointClass = Point2()
//
//// Инкапсуляция
//
//class BankAccount {
//    private var balance: Double = 0.0
//    
//    func calc(symbol: Character, count: Int) {
//        switch symbol {
//        case "+": addBalance(countPoint: count)
//        case "-": minusBalance(countPoint: count)
//        default: 0
//        }
//    }
//    
//    private func addBalance(countPoint: Int) {
//        balance += Double(countPoint)
//    }
//    private func minusBalance(countPoint: Int) {
//        balance += Double(countPoint)
//    }
//    
//    func displayBalance() {
//        print(balance)
//    }
//}
//
//
//let account = BankAccount()
//
//account.calc(symbol: "+", count: 100)

// Наследование

//class Arena {
//    let boxer = Boxer()
//    let wrestler = Wrestler()
//}
//
//class Fighter {
//    
//    var hp: Int
//    
//    func superAttack() {
//        print("Боец атакует")
//    }
//    
//    init() {
//        self.hp = 100
//    }
//}
//
//class Boxer: Fighter {
//    override func superAttack() {
//        super.superAttack()
//        print("Мощный удар")
//    }
//    
//    override init() {
//        super.init()
//        self.hp = 50
//    }
//}
//
//class Wrestler: Fighter {
//    override func superAttack() {
//        super.superAttack()
//        print("Опрокинул соперника")
//    }
//    override init() {
//        super.init()
//        self.hp = 200
//    }
//}
//
//let boxer = Boxer()
//let wrestler = Wrestler()
//
//print(boxer.hp)
//print(wrestler.hp)
